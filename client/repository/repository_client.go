// Code generated by go-swagger; DO NOT EDIT.

package repository

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new repository API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for repository API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateFork forks a repository
*/
func (a *Client) CreateFork(params *CreateForkParams, authInfo runtime.ClientAuthInfoWriter) (*CreateForkAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateForkParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createFork",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/forks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateForkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateForkAccepted), nil

}

/*
ListForks lists a repository s forks
*/
func (a *Client) ListForks(params *ListForksParams, authInfo runtime.ClientAuthInfoWriter) (*ListForksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListForksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listForks",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/forks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListForksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListForksOK), nil

}

/*
RepoAddCollaborator adds a collaborator to a repository
*/
func (a *Client) RepoAddCollaborator(params *RepoAddCollaboratorParams, authInfo runtime.ClientAuthInfoWriter) (*RepoAddCollaboratorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoAddCollaboratorParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoAddCollaborator",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoAddCollaboratorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoAddCollaboratorNoContent), nil

}

/*
RepoCheckCollaborator checks if a user is a collaborator of a repository
*/
func (a *Client) RepoCheckCollaborator(params *RepoCheckCollaboratorParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCheckCollaboratorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCheckCollaboratorParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCheckCollaborator",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCheckCollaboratorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCheckCollaboratorNoContent), nil

}

/*
RepoCreateHook creates a hook
*/
func (a *Client) RepoCreateHook(params *RepoCreateHookParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCreateHookCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateHookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCreateHook",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/hooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCreateHookCreated), nil

}

/*
RepoCreateKey adds a key to a repository
*/
func (a *Client) RepoCreateKey(params *RepoCreateKeyParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCreateKeyCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCreateKey",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/keys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCreateKeyCreated), nil

}

/*
RepoCreatePullRequest creates a pull request
*/
func (a *Client) RepoCreatePullRequest(params *RepoCreatePullRequestParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCreatePullRequestCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreatePullRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCreatePullRequest",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreatePullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCreatePullRequestCreated), nil

}

/*
RepoCreateRelease creates a release
*/
func (a *Client) RepoCreateRelease(params *RepoCreateReleaseParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCreateReleaseCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateReleaseParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCreateRelease",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/releases",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCreateReleaseCreated), nil

}

/*
RepoCreateReleaseAttachment creates a release attachment
*/
func (a *Client) RepoCreateReleaseAttachment(params *RepoCreateReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCreateReleaseAttachmentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateReleaseAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCreateReleaseAttachment",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCreateReleaseAttachmentCreated), nil

}

/*
RepoCreateStatus creates a commit status
*/
func (a *Client) RepoCreateStatus(params *RepoCreateStatusParams, authInfo runtime.ClientAuthInfoWriter) (*RepoCreateStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoCreateStatus",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/statuses/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoCreateStatusOK), nil

}

/*
RepoDelete deletes a repository
*/
func (a *Client) RepoDelete(params *RepoDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*RepoDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoDelete",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoDeleteNoContent), nil

}

/*
RepoDeleteCollaborator deletes a collaborator from a repository
*/
func (a *Client) RepoDeleteCollaborator(params *RepoDeleteCollaboratorParams, authInfo runtime.ClientAuthInfoWriter) (*RepoDeleteCollaboratorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteCollaboratorParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoDeleteCollaborator",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteCollaboratorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoDeleteCollaboratorNoContent), nil

}

/*
RepoDeleteHook deletes a hook in a repository
*/
func (a *Client) RepoDeleteHook(params *RepoDeleteHookParams, authInfo runtime.ClientAuthInfoWriter) (*RepoDeleteHookNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteHookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoDeleteHook",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoDeleteHookNoContent), nil

}

/*
RepoDeleteKey deletes a key from a repository
*/
func (a *Client) RepoDeleteKey(params *RepoDeleteKeyParams, authInfo runtime.ClientAuthInfoWriter) (*RepoDeleteKeyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoDeleteKey",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/keys/{id}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoDeleteKeyNoContent), nil

}

/*
RepoDeleteRelease deletes a release
*/
func (a *Client) RepoDeleteRelease(params *RepoDeleteReleaseParams, authInfo runtime.ClientAuthInfoWriter) (*RepoDeleteReleaseNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteReleaseParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoDeleteRelease",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoDeleteReleaseNoContent), nil

}

/*
RepoDeleteReleaseAttachment deletes a release attachment
*/
func (a *Client) RepoDeleteReleaseAttachment(params *RepoDeleteReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter) (*RepoDeleteReleaseAttachmentNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteReleaseAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoDeleteReleaseAttachment",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoDeleteReleaseAttachmentNoContent), nil

}

/*
RepoEditHook edits a hook in a repository
*/
func (a *Client) RepoEditHook(params *RepoEditHookParams, authInfo runtime.ClientAuthInfoWriter) (*RepoEditHookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditHookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoEditHook",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoEditHookOK), nil

}

/*
RepoEditPullRequest updates a pull request
*/
func (a *Client) RepoEditPullRequest(params *RepoEditPullRequestParams, authInfo runtime.ClientAuthInfoWriter) (*RepoEditPullRequestCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditPullRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoEditPullRequest",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditPullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoEditPullRequestCreated), nil

}

/*
RepoEditRelease updates a release
*/
func (a *Client) RepoEditRelease(params *RepoEditReleaseParams, authInfo runtime.ClientAuthInfoWriter) (*RepoEditReleaseOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditReleaseParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoEditRelease",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoEditReleaseOK), nil

}

/*
RepoEditReleaseAttachment edits a release attachment
*/
func (a *Client) RepoEditReleaseAttachment(params *RepoEditReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter) (*RepoEditReleaseAttachmentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditReleaseAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoEditReleaseAttachment",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoEditReleaseAttachmentCreated), nil

}

/*
RepoGet gets a repository
*/
func (a *Client) RepoGet(params *RepoGetParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGet",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetOK), nil

}

/*
RepoGetArchive gets an archive of a repository
*/
func (a *Client) RepoGetArchive(params *RepoGetArchiveParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetArchiveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetArchiveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetArchive",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/archive/{archive}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetArchiveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetArchiveOK), nil

}

/*
RepoGetBranch lists a repository s branches
*/
func (a *Client) RepoGetBranch(params *RepoGetBranchParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetBranchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetBranchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetBranch",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/branches/{branch}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetBranchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetBranchOK), nil

}

/*
RepoGetByID gets a repository by id
*/
func (a *Client) RepoGetByID(params *RepoGetByIDParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetByID",
		Method:             "GET",
		PathPattern:        "/repositories/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetByIDOK), nil

}

/*
RepoGetCombinedStatusByRef gets a commit s combined status by branch tag commit reference
*/
func (a *Client) RepoGetCombinedStatusByRef(params *RepoGetCombinedStatusByRefParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetCombinedStatusByRefOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetCombinedStatusByRefParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetCombinedStatusByRef",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/commits/{ref}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetCombinedStatusByRefReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetCombinedStatusByRefOK), nil

}

/*
RepoGetEditorConfig gets the editor config definitions of a file in a repository
*/
func (a *Client) RepoGetEditorConfig(params *RepoGetEditorConfigParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetEditorConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetEditorConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetEditorConfig",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/editorconfig/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetEditorConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetEditorConfigOK), nil

}

/*
RepoGetHook gets a hook
*/
func (a *Client) RepoGetHook(params *RepoGetHookParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetHookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetHookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetHook",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetHookOK), nil

}

/*
RepoGetKey gets a repository s key by id
*/
func (a *Client) RepoGetKey(params *RepoGetKeyParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetKey",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/keys/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetKeyOK), nil

}

/*
RepoGetPullRequest gets a pull request
*/
func (a *Client) RepoGetPullRequest(params *RepoGetPullRequestParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetPullRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetPullRequest",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetPullRequestOK), nil

}

/*
RepoGetRawFile gets a file from a repository
*/
func (a *Client) RepoGetRawFile(params *RepoGetRawFileParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetRawFileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetRawFileParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetRawFile",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/raw/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetRawFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetRawFileOK), nil

}

/*
RepoGetRelease gets a release
*/
func (a *Client) RepoGetRelease(params *RepoGetReleaseParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetReleaseOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetReleaseParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetRelease",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetReleaseOK), nil

}

/*
RepoGetReleaseAttachment gets a release attachment
*/
func (a *Client) RepoGetReleaseAttachment(params *RepoGetReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter) (*RepoGetReleaseAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetReleaseAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoGetReleaseAttachment",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoGetReleaseAttachmentOK), nil

}

/*
RepoListBranches lists a repository s branches
*/
func (a *Client) RepoListBranches(params *RepoListBranchesParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListBranchesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListBranchesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListBranches",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/branches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListBranchesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListBranchesOK), nil

}

/*
RepoListCollaborators lists a repository s collaborators
*/
func (a *Client) RepoListCollaborators(params *RepoListCollaboratorsParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListCollaboratorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListCollaboratorsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListCollaborators",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/collaborators",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListCollaboratorsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListCollaboratorsOK), nil

}

/*
RepoListHooks lists the hooks in a repository
*/
func (a *Client) RepoListHooks(params *RepoListHooksParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListHooksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListHooksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListHooks",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/hooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListHooksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListHooksOK), nil

}

/*
RepoListKeys lists a repository s keys
*/
func (a *Client) RepoListKeys(params *RepoListKeysParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListKeysOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListKeysParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListKeys",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/keys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListKeysReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListKeysOK), nil

}

/*
RepoListPullRequests lists a repo s pull requests
*/
func (a *Client) RepoListPullRequests(params *RepoListPullRequestsParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListPullRequestsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListPullRequestsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListPullRequests",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListPullRequestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListPullRequestsOK), nil

}

/*
RepoListReleaseAttachments lists release s attachments
*/
func (a *Client) RepoListReleaseAttachments(params *RepoListReleaseAttachmentsParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListReleaseAttachmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListReleaseAttachmentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListReleaseAttachments",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListReleaseAttachmentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListReleaseAttachmentsOK), nil

}

/*
RepoListReleases lists a repo s releases
*/
func (a *Client) RepoListReleases(params *RepoListReleasesParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListReleasesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListReleasesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListReleases",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListReleasesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListReleasesOK), nil

}

/*
RepoListStargazers lists a repo s stargazers
*/
func (a *Client) RepoListStargazers(params *RepoListStargazersParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListStargazersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListStargazersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListStargazers",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/stargazers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListStargazersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListStargazersOK), nil

}

/*
RepoListStatuses gets a commit s statuses
*/
func (a *Client) RepoListStatuses(params *RepoListStatusesParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListStatusesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListStatusesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListStatuses",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/statuses/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListStatusesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListStatusesOK), nil

}

/*
RepoListSubscribers lists a repo s watchers
*/
func (a *Client) RepoListSubscribers(params *RepoListSubscribersParams, authInfo runtime.ClientAuthInfoWriter) (*RepoListSubscribersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListSubscribersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoListSubscribers",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/subscribers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListSubscribersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoListSubscribersOK), nil

}

/*
RepoMergePullRequest merges a pull request
*/
func (a *Client) RepoMergePullRequest(params *RepoMergePullRequestParams, authInfo runtime.ClientAuthInfoWriter) (*RepoMergePullRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoMergePullRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoMergePullRequest",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/merge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoMergePullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoMergePullRequestOK), nil

}

/*
RepoMigrate migrates a remote git repository
*/
func (a *Client) RepoMigrate(params *RepoMigrateParams, authInfo runtime.ClientAuthInfoWriter) (*RepoMigrateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoMigrateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoMigrate",
		Method:             "POST",
		PathPattern:        "/repos/migrate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoMigrateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoMigrateCreated), nil

}

/*
RepoMirrorSync syncs a mirrored repository
*/
func (a *Client) RepoMirrorSync(params *RepoMirrorSyncParams, authInfo runtime.ClientAuthInfoWriter) (*RepoMirrorSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoMirrorSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoMirrorSync",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/mirror-sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoMirrorSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoMirrorSyncOK), nil

}

/*
RepoPullRequestIsMerged checks if a pull request has been merged
*/
func (a *Client) RepoPullRequestIsMerged(params *RepoPullRequestIsMergedParams, authInfo runtime.ClientAuthInfoWriter) (*RepoPullRequestIsMergedNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoPullRequestIsMergedParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoPullRequestIsMerged",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/merge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoPullRequestIsMergedReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoPullRequestIsMergedNoContent), nil

}

/*
RepoSearch searches for repositories
*/
func (a *Client) RepoSearch(params *RepoSearchParams, authInfo runtime.ClientAuthInfoWriter) (*RepoSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoSearch",
		Method:             "GET",
		PathPattern:        "/repos/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoSearchOK), nil

}

/*
RepoTestHook tests a push webhook
*/
func (a *Client) RepoTestHook(params *RepoTestHookParams, authInfo runtime.ClientAuthInfoWriter) (*RepoTestHookNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoTestHookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoTestHook",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}/tests",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoTestHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoTestHookNoContent), nil

}

/*
RepoTrackedTimes lists a repo s tracked times
*/
func (a *Client) RepoTrackedTimes(params *RepoTrackedTimesParams, authInfo runtime.ClientAuthInfoWriter) (*RepoTrackedTimesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoTrackedTimesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "repoTrackedTimes",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/times",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoTrackedTimesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RepoTrackedTimesOK), nil

}

/*
TopicSearch searches topics via keyword
*/
func (a *Client) TopicSearch(params *TopicSearchParams, authInfo runtime.ClientAuthInfoWriter) (*TopicSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTopicSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "topicSearch",
		Method:             "GET",
		PathPattern:        "/topics/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TopicSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TopicSearchOK), nil

}

/*
UserCurrentCheckSubscription checks if the current user is watching a repo
*/
func (a *Client) UserCurrentCheckSubscription(params *UserCurrentCheckSubscriptionParams, authInfo runtime.ClientAuthInfoWriter) (*UserCurrentCheckSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCurrentCheckSubscriptionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "userCurrentCheckSubscription",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/subscription",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserCurrentCheckSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserCurrentCheckSubscriptionOK), nil

}

/*
UserCurrentDeleteSubscription unwatches a repo
*/
func (a *Client) UserCurrentDeleteSubscription(params *UserCurrentDeleteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter) (*UserCurrentDeleteSubscriptionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCurrentDeleteSubscriptionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "userCurrentDeleteSubscription",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/subscription",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserCurrentDeleteSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserCurrentDeleteSubscriptionNoContent), nil

}

/*
UserCurrentPutSubscription watches a repo
*/
func (a *Client) UserCurrentPutSubscription(params *UserCurrentPutSubscriptionParams, authInfo runtime.ClientAuthInfoWriter) (*UserCurrentPutSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCurrentPutSubscriptionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "userCurrentPutSubscription",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/subscription",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserCurrentPutSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserCurrentPutSubscriptionOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
